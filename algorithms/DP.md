### Binary search
```cpp
while (l < r) {    //важно что тут сразу все плохо, а потом хорошо
        int mid = (l + r) / 2;
        if (good(mid)) r = mid;
        else l = mid + 1;
    }
```


### Отрезки с нулевой суммой
Двигаемся по массиву и записываем в словарь индексы элемента с префиксной суммой в качестве ключа. На каждом элементе смотрим сколько до этого было элементов с той же префиксной суммой.

### Очередь
Покупать билет можно себе или себе и следующему.

```cpp
dp[k] = std::min(dp[k - 1] + A[k], dp[k - 2] + B[k - 1]);
```

### Cтоловая 
За обеды дороже $p$ дают купоны на бесаплатный обед. В динамике $c$ - кол-во купонов.

```cpp
dp[k][c] = std::min(dp[k - 1][c + 1], 
(p_[k] < p) ?  dp[k - 1][c] + p_[k] : dp[k - 1][c - 1] + p_[k]);
```

### Наибольшая общая подпоследовательность
```cpp
if (a[i] != b[j]) dp[i][j] = std::max(dp[i][j - 1], dp[i - 1][j]);
else dp[i][j] = dp[i - 1][j - 1] + 1;
```

### Еловый лес
Нудно посадить как можно больше деревьев на отрезке, у каждого сорта есть тень на запад и на тень на восток, в котрых садить другие деревья нельзя.
В динамике $i$ - номер последней занятой лунки, $j$ - кол-во ёлок, а в двумерном массиве храним сорта елок. Тогда $dp[i][j] = dp[k][j - 1] : k \in [j - 1, i - 1]$, для самого первого $dp[k][j - 1]$, которое не закрывает лунку выбираем подходящий сорт с минимальной тенью на восток и выходим из третьего цикла.

