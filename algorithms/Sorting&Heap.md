| Сортировки | Время | Память |  Персистентность | Присвоение |
|------------|------------|------------|------------|------------|
| Слиянием | $O(n \log{n})$ | $O(n)$ | да | $O(n \log{n})$ |
| Пирамидальная | $O(n \log{n})$ | $O(1)$ | нет | $O(n \log{n})$ |

## Сортировка слиянием
Умеем объединять два отсортированных массива. Разбиваем на два и рекуррентно запускаем.

## Куча
Плотное двоичное дерево, где предок не меньше потомков. Для вставки добавляем лист, а потом shift up. Для удаления максимума меняем местами крайний правый лист и вершину, безболезненно его удаляем, а потом shift down. Постройка из массива дает наименьшую константу.

```cpp
#define assign(i, vct)        \
l = 2 * i + 1;                 \
r = 2 * i + 2;                  \
lv = l < n ? vct[l] : INT32_MIN; \
rv = l < n ? vct[r] : INT32_MIN;  \


void shift_down(unsigned long n,  std::vector<int> &vct, int i) {
    int l, r, lv, rv;
    assign(i, vct)
    while (vct[i] < lv || vct[i] < rv) {
        if (rv > lv) { lv = rv; l = r; }    //левый теперь обозначает большего потомка
        vct[l] = vct[i];    //меняем местами большего потомка с корнем
        vct[i] = lv;
        i = l;
        assign(i, vct)
    }
}

void build(unsigned long n, std::vector<int> &vct) {    //в корне максимум
    for (int i = n / 2; i >= 0; --i) { shift_down(n, vct, i); }
}
```

## Пирамидальная сортировка
Удаляем максимумы и помещаем их в крайние правые листья. На практике работает медленнее из-за непоследовательного доступа к элементам.


