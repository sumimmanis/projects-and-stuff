| Сортировки | Время | Память |  Персистентность | 
|------------|------------|------------|------------|
| Слиянием | $O(n \log{n})$ | $O(n)$ | да |
| Пирамидальная | $O(n \log{n})$ | $O(1)$ | нет | 
| Подсчетом | $O(n + k)$ | $O(k)$ | нет | 
| Поразрядная | $O(q \cdot (n + k))$| $O(n)$ | да | 



## Сортировка слиянием
Умеем объединять два отсортированных массива. Разбиваем на два и рекурсивно запускаем.

## Куча
Плотное двоичное дерево, где предок не меньше потомков. Для вставки добавляем лист, а потом shift up. Для удаления максимума меняем местами крайний правый лист и вершину, безболезненно его удаляем, а потом shift down. Постройка из массива дает наименьшую константу.

```cpp
#define assign(i, vct)        \
l = 2 * i + 1;                 \
r = 2 * i + 2;                  \
lv = l < n ? vct[l] : INT32_MIN; \
rv = l < n ? vct[r] : INT32_MIN;  \


void shift_down(unsigned long n,  std::vector<int> &vct, int i) {
    int l, r, lv, rv;
    assign(i, vct)
    while (vct[i] < lv || vct[i] < rv) {
        if (rv > lv) { lv = rv; l = r; }    //левый теперь обозначает большего потомка
        vct[l] = vct[i];    //меняем местами большего потомка с корнем
        vct[i] = lv;
        i = l;
        assign(i, vct)
    }
}

void build(unsigned long n, std::vector<int> &vct) {    //в корне максимум
    for (int i = n / 2; i >= 0; --i) { shift_down(n, vct, i); }
}
```

## Пирамидальная сортировка
Из кучи удаляем максимумы и помещаем их в крайние правые листья. На практике работает медленнее из-за непоследовательного доступа к элементам.

## Сортировка подсчетом
Пусть максимум не превосходит $k$. Создадим массив длины $k$ и для каждого заданного элемента будем инкрементировать соответствующую позицию в массиве.

## Поразрядная сортировка
Пусть даны числа сочтоящие из $q$ цифр в системе исчисления с $k$ цифрами. Начинаем сортировку с цифр последнего разряда. Делаем сортировку подсчетом и для нее считаем префиксную сумму. Заводим массив длины $n$ и для каждого числа берем его цифру $i$ из нужного разряда, на позиции $i$ префиксной суммы берем число $j$ и затем инкрементируем число на той позиции. На позицию $j$ массива записываем число. 


